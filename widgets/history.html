<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Subathon Timer History</title>
  <link type='text/css' rel='stylesheet' href='widgets.css'>
  <script src="./socket.io.js"></script>
</head>
<body>
  <p style="text-shadow: 0 0 10px transparent; color: transparent; white-space: nowrap">0:00</p>
<div style="background: transparent">
  <span></span>
  <canvas></canvas>
</div>
<script>
  // TODO move script to src/scripts or resources/scripts? typescript?
  // TODO clean up code, add comments (like timer.html)

  // graph
  let history = []; // cache history to update graph if config changes
  const canvas = document.getElementsByTagName('canvas')[0];
  const ctx = canvas.getContext('2d');
  ctx.lineWidth = 5; // TODO reduce width if timespan greater than x? add to config?
  ctx.lineJoin = 'bevel';

  // register events
  const socket = io("/history");
  socket.on('connect', () => {
    console.log('Connected to timer.');
    document.querySelector('span').innerText = "";
  });
  socket.on('disconnect', () => {
    console.log("Connection to timer lost.")
    document.querySelector('span').innerText = "Not connected to timer";
    document.querySelector('p').innerText = "";
    ctx.clearRect(0, 0, canvas.width, canvas.height);
  });
  socket.on('error', msg => {
    document.querySelector('span').innerText = msg;
  });
  socket.on('config', config => updateConfig(config));
  socket.on('update', data => setTime(data.totalTimeString));
  socket.on('history-data', historyData => {
    history = historyData
    drawLine(history);
  });
  socket.on('history-export', (bgColor, callback) => {
    const globalCompositeOperation = ctx.globalCompositeOperation;
    ctx.globalCompositeOperation = 'destination-over';
    ctx.fillStyle = bgColor;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    callback(canvas.toDataURL());
    ctx.globalCompositeOperation = globalCompositeOperation;
  });

  /**
   * Update the configuration based on the provided config.
   *
   * @param config the config containing the new values that should be used
   */
  const updateConfig = (config) => {
    document.querySelector('p').hidden = !config.timerHistoryShowTotal;

    document.querySelector('div').style.background = config.bgColor;
    document.querySelector('p').style.color = config.timerColor;
    document.querySelector('p').style.textShadow = `0px 0px 10px ${config.timerShadowColor}`;
    ctx.strokeStyle = config.lineColor;

    drawLine(history);
  }

  /**
   * Update the displayed total time to the given time.
   *
   * @param timeAsString the timer after update formatted to be displayed
   */
  const setTime = timeAsString => {
    document.querySelector('p').innerText = timeAsString ? timeAsString : "";
  };

  /**
   * Normalize values in array (between 0 and 1).
   *
   * @param values the array to normalize
   * @returns {*[]} the array with the normalized values
   */
  const getNormalizedValues = (values) => {
    // TODO [#21] always scale y with 0 as lowest
    let min = Math.min.apply(Math, values);
    let max = Math.max.apply(Math, values);

    let normalized = [];
    for (let value of values) {
      if (Number.isInteger(value)) {
        normalized.push((value - min) / (max - min));
      }
    }
    return normalized;
  };

  /**
   * Draw the line graph of the total history of the provided data.
   *
   * @param data the graph data
   */
  const drawLine = (data) => {
    data = data
      .map(item => {
        const timestamp = Date.parse(item.timestamp); // parse date to a number
        return { ...item, timestamp };
      })
      .filter(item => Number.isInteger(item.timestamp) && Number.isInteger(item.time)) // remove invalid data points
      .sort((a, b) => a.timestamp - b.timestamp); // sort by timestamp in case json file is weird

    let dates = getNormalizedValues(data.map(value => value.timestamp));
    let times = getNormalizedValues(data.map(value => value.time)).map(time => 1 - time);

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // calc offsets so the line is not cut off at the edge
    const offset = ctx.lineWidth / 2;
    const width = canvas.width - ctx.lineWidth;
    const height = canvas.height - ctx.lineWidth;

    ctx.beginPath();
    ctx.moveTo(0, height * times[0] + offset);
    for (let i = 0; i < data.length; i++) {
      ctx.lineTo(width * dates[i] + offset, height * times[i] + offset);
    }
    ctx.lineTo(canvas.width, height * times[data.length - 1] + offset)
    ctx.stroke();
  };
</script>
</body>
</html>
